datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

enum MembershipType {
  full
  social
  junior
}

enum Difficulty {
  easy
  moderate
  hard
  expert
}

enum RouteType {
  road
  mountain
  gravel
  mixed
}

enum EventType {
  group_ride
  training
  race
  social
}

enum EventStatus {
  scheduled
  cancelled
  completed
}

enum ParticipationStatus {
  registered
  attended
  no_show
}

enum UserRole {
  public
  user
  member
  admin
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  password      String? // Hashed password
  image         String?
  role          UserRole  @default(user)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts            Account[]
  sessions            Session[]
  member              Member?
  organizedEvents     Event[]              @relation("EventOrganizer")
  eventParticipants   Event[]              @relation("EventParticipants")
  eventWaitingList    Event[]              @relation("EventWaitingList")
  uploadedRoutes      Route[]
  eventParticipations EventParticipation[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Member {
  id               String         @id @default(cuid())
  userId           String         @unique
  firstName        String
  lastName         String
  email            String
  phone            String?
  emergencyContact String?
  emergencyPhone   String?
  membershipType   MembershipType
  joinDate         DateTime       @default(now())
  isActive         Boolean        @default(true)
  isPaid           Boolean        @default(false)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
}

model Route {
  id               String     @id @default(cuid())
  name             String
  description      String?
  distance         Float // in kilometers
  elevation        Float // in meters (kept for backward compatibility, represents ascent)
  elevationAscent  Float? // in meters
  elevationDescent Float? // in meters
  difficulty       Difficulty
  gpxFileUrl       String? // URL to stored GPX file
  gpxFileName      String?
  uploadedBy       String
  uploadDate       DateTime   @default(now())
  startLocation    String
  endLocation      String?
  routeType        RouteType
  tags             String[]   @default([])
  eventCount       Int        @default(0)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  user   User    @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)
  events Event[]

  @@index([uploadedBy])
  @@index([difficulty])
  @@index([routeType])
}

model Event {
  id                String      @id @default(cuid())
  title             String
  description       String?
  date              DateTime
  startTime         String // HH:MM format
  duration          Int? // in minutes
  routeId           String?
  meetingPoint      String
  maxParticipants   Int?
  difficulty        Difficulty
  eventType         EventType
  stravaEventUrl    String?
  organizer         String
  status            EventStatus @default(scheduled)
  weatherConditions String?
  notes             String?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  route          Route?               @relation(fields: [routeId], references: [id], onDelete: SetNull)
  organizerUser  User                 @relation("EventOrganizer", fields: [organizer], references: [id], onDelete: Cascade)
  participants   User[]               @relation("EventParticipants")
  waitingList    User[]               @relation("EventWaitingList")
  participations EventParticipation[]

  @@index([date])
  @@index([organizer])
  @@index([routeId])
  @@index([status])
}

model EventParticipation {
  id               String              @id @default(cuid())
  eventId          String
  userId           String
  status           ParticipationStatus @default(registered)
  registrationDate DateTime            @default(now())
  notes            String?
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([eventId, userId])
}
